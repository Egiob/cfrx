import jax
import jax.numpy as jnp
import pgx
from jaxtyping import Array

from cfrx.metrics.best_response import compute_best_response_value
from cfrx.policy import Float, Policy
from cfrx.tree import Root
from cfrx.tree.traverse import instantiate_tree_from_root, traverse_tree_cfr


def exploitability(
    env: pgx.Env,
    policy: Policy,
    policy_params: Array,
    n_players: int,
    n_max_nodes: int = 100,
) -> Float[Array, ""]:
    random_key = jax.random.PRNGKey(0)
    state = jax.jit(env.init)(random_key)

    values_list = []
    root = Root(
        prior_logits=state.legal_action_mask / state.legal_action_mask.sum(),
        value=jnp.array(0.0),
        state=state,
    )
    for traverser in range(n_players):
        tree = instantiate_tree_from_root(
            root=root,
            n_max_nodes=n_max_nodes,
            n_players=n_players,
            running_probabilities=True,
        )

        tree = traverse_tree_cfr(
            tree,
            policy=policy,
            env=env,
            traverser=traverser,
            policy_params=policy_params,
        )
        value = compute_best_response_value(
            tree, br_player=traverser, info_state_fn=env.info_state_idx
        )
        values_list.append(value)

    values = jnp.stack(values_list)
    exploitability = jnp.array(values).sum() / n_players
    return exploitability
