import jax
import jax.numpy as jnp
import pgx
from jaxtyping import Array

from cfrx.metrics.best_response import compute_best_response_value
from cfrx.policy import Float, Policy
from cfrx.tree import Root
from cfrx.tree.traverse import instantiate_tree_from_root, traverse_tree_cfr
from cfrx.utils import log_array


def compute_exploitability_value(
    env: pgx.Env,
    policy: Policy,
    policy_params: Array,
    num_players: int,
    num_max_nodes: int = 100,
) -> Float[Array, ""]:
    random_key = jax.random.PRNGKey(0)
    state = jax.jit(env.init)(random_key)

    values_list = []
    root = Root(
        prior_logits=state.legal_action_mask / state.legal_action_mask.sum(),
        value=jnp.array(0.0),
        state=state,
    )
    for traverser in range(num_players):
        tree = instantiate_tree_from_root(
            root=root,
            num_max_nodes=num_max_nodes,
            num_players=num_players,
            running_probabilities=True,
        )

        tree = traverse_tree_cfr(
            tree,
            policy=policy,
            env=env,
            traverser=traverser,
            policy_params=policy_params,
        )
        value = compute_best_response_value(
            tree, br_player=traverser, info_state_fn=env.info_state_idx
        )
        values_list.append(value)

    values = jnp.stack(values_list)
    log_array(values, "exploitabilities")
    exploitability = jnp.array(values).sum() / num_players
    return exploitability
